import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import globby from 'globby';
import { sync } from 'cross-spawn';

declare function jscodeshiftToPrettierParser(parser?: string): string;

const packageNames = {
  '@kadira/react-storybook-decorator-centered': '@storybook/addon-centered',
  '@kadira/storybook-addons': '@storybook/addons',
  '@kadira/storybook-addon-actions': '@storybook/addon-actions',
  '@kadira/storybook-addon-comments': '@storybook/addon-comments',
  '@kadira/storybook-addon-graphql': '@storybook/addon-graphql',
  '@kadira/storybook-addon-info': '@storybook/addon-info',
  '@kadira/storybook-addon-knobs': '@storybook/addon-knobs',
  '@kadira/storybook-addon-links': '@storybook/addon-links',
  '@kadira/storybook-addon-notes': '@storybook/addon-notes',
  '@kadira/storybook-addon-options': '@storybook/addon-options',
  '@kadira/storybook-channels': '@storybook/channels',
  '@kadira/storybook-channel-postmsg': '@storybook/channel-postmessage',
  '@kadira/storybook-channel-websocket': '@storybook/channel-websocket',
  '@kadira/storybook-ui': '@storybook/ui',
  '@kadira/react-native-storybook': '@storybook/react-native',
  '@kadira/react-storybook': '@storybook/react',
  '@kadira/getstorybook': '@storybook/cli',
  '@kadira/storybook': '@storybook/react',
  storyshots: '@storybook/addon-storyshots',
  getstorybook: '@storybook/cli',
};

function transformer$1(file, api) {
  const j = api.jscodeshift;

  const packageNamesKeys = Object.keys(packageNames);

  /**
   * Checks whether the node value matches a Storybook package
   * @param {string} the import declaration node
   * @returns {string} whether the node value matches a Storybook package
   */
  const getMatch = (oldpart) => packageNamesKeys.find((newpart) => oldpart.match(newpart));

  /**
   * Returns the name of the Storybook packages with the organisation name,
   * replacing the old `@kadira/` prefix.
   * @param {string} oldPackageName the name of the old package
   * @return {string} the new package name
   * @example
   * // returns '@storybook/storybook'
   * getNewPackageName('@kadira/storybook')
   */
  const getNewPackageName = (oldPackageName) => {
    const match = getMatch(oldPackageName);

    if (match) {
      const replacement = packageNames[match];
      return oldPackageName.replace(match, replacement);
    }
    return oldPackageName;
  };

  /**
   * updatePackageName - updates the source name of the Storybook packages
   * @param {ImportDeclaration} declaration the import declaration
   * @returns {ImportDeclaration.Node} the import declaration node
   */
  const updatePackageName = (declaration) => {
    // eslint-disable-next-line no-param-reassign
    declaration.node.source.value = getNewPackageName(declaration.node.source.value);

    return declaration.node;
  };

  return j(file.source)
    .find(j.ImportDeclaration)
    .replaceWith(updatePackageName)
    .toSource({ quote: 'single' });
}

/**
 * Takes the deprecated addon-info API, addWithInfo, and
 * converts to the new withInfo API.
 *
 * Example of deprecated addWithInfo API:
 *
 * storiesOf('Button')
 *   .addWithInfo(
 *     'story name',
 *     'Story description.',
 *     () => (
 *       <Button label="The Button" />
 *     )
 *   )
 *
 * Converts to the new withInfo API:
 *
 * storiesOf('Button')
 *   .add('story name', withInfo(
 *     'Story description.'
 *   )(() => (
 *     <Button label="The Button" />
 *   )))
 */
function transformer(file, api) {
  const j = api.jscodeshift;
  const root = j(file.source);

  /**
   * Returns a list of parameters for the withInfo function. The contents
   * of this list is either the second argument from the original
   * addWithInfo function, if no additional options were used, or a
   * combined object of all the options from the original function.
   * @param {list} args - original addWithInfo function parameters
   * @return {list} the modified list of parameters for the new function
   */
  const getOptions = (args) => {
    if (args[3] === undefined) {
      if (args[2] === undefined) {
        // when the optional description string is not supplied for addWithInfo, use story name
        return [args[0]];
      }
      return [args[1]];
    }
    return [
      j.objectExpression([
        j.property('init', j.identifier('text'), args[1]),
        ...args[3].properties,
      ]),
    ];
  };

  /**
   * Constructs the new withInfo function from the parameters of the
   * original addWithInfo function.
   * @param {CallExpression} addWithInfoExpression - original function
   * @returns {CallExpression} the new withInfo function
   */
  const withInfo = (addWithInfoExpression) => {
    const { node } = addWithInfoExpression;
    const args = node.arguments;

    // if optional description string is not supplied, the story component becomes second arg
    const storyComponent = args[2] ? args[2] : args[1];

    node.callee.property.name = 'add';
    node.arguments = [
      args[0],
      j.callExpression(j.callExpression(j.identifier('withInfo'), getOptions(args)), [
        storyComponent,
      ]),
    ];

    return node;
  };

  /**
   * Checks for - import { withInfo } from "@storybook/addon-info";
   * Adds the import if necessary.
   */
  const checkWithInfoImport = () => {
    const importExists = root
      .find(j.ImportDeclaration)
      .filter((imp) => imp.node.source.value === '@storybook/addon-info')
      .size();

    if (importExists) return;

    root
      .find(j.ImportDeclaration)
      .at(-1)
      .insertAfter(
        j.importDeclaration(
          [j.importSpecifier(j.identifier('withInfo'))],
          j.literal('@storybook/addon-info')
        )
      );
  };

  const addWithInfoExpressions = root.find(j.CallExpression, {
    callee: {
      property: {
        name: 'addWithInfo',
      },
    },
  });

  if (addWithInfoExpressions.size()) {
    checkWithInfoImport();
    addWithInfoExpressions.replaceWith(withInfo);
  }

  return root.toSource();
}

/* eslint import/prefer-default-export: "off" */

const TRANSFORM_DIR = `${__dirname}/transforms`;

function listCodemods() {
  return fs
    .readdirSync(TRANSFORM_DIR)
    .filter((fname) => fname.endsWith('.js'))
    .map((fname) => fname.slice(0, -3));
}

const renameAsync = promisify(fs.rename);

async function renameFile(file, from, to, { logger }) {
  const newFile = file.replace(from, to);
  logger.log(`Rename: ${file} ${newFile}`);
  return renameAsync(file, newFile);
}

async function runCodemod(codemod, { glob, logger, dryRun, rename, parser }) {
  const codemods = listCodemods();
  if (!codemods.includes(codemod)) {
    throw new Error(`Unknown codemod ${codemod}. Run --list for options.`);
  }

  let renameParts = null;
  if (rename) {
    renameParts = rename.split(':');
    if (renameParts.length !== 2) {
      throw new Error(`Codemod rename: expected format "from:to", got "${rename}"`);
    }
  }

  // jscodeshift/prettier know how to handle .ts/.tsx extensions,
  // so if the user uses one of those globs, we can auto-infer
  let inferredParser = parser;
  if (!parser) {
    const extension = path.extname(glob).slice(1);
    const knownParser = jscodeshiftToPrettierParser(extension);
    if (knownParser !== 'babel') inferredParser = extension;
  }

  const files = await globby([glob, '!**/node_modules', '!**/dist']);
  logger.log(`=> Applying ${codemod}: ${files.length} files`);
  if (!dryRun) {
    const parserArgs = inferredParser ? ['--parser', inferredParser] : [];
    sync(
      'npx',
      ['jscodeshift', '-t', `${TRANSFORM_DIR}/${codemod}.js`, ...parserArgs, ...files],
      {
        stdio: 'inherit',
        shell: true,
      }
    );
  }

  if (renameParts) {
    const [from, to] = renameParts;
    logger.log(`=> Renaming ${rename}: ${files.length} files`);
    await Promise.all(
      files.map((file) => renameFile(file, new RegExp(`${from}$`), to, { logger }))
    );
  }
}

export { listCodemods, packageNames, runCodemod, transformer as updateAddonInfo, transformer$1 as updateOrganisationName };
